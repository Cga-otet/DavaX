SET SERVEROUTPUT ON;

-- Part 1
CREATE TABLE debug_log (
    log_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    log_time TIMESTAMP DEFAULT SYSTIMESTAMP,
    module_name VARCHAR2(100),
    line_no NUMBER,
    log_message VARCHAR2(4000),
    session_id VARCHAR2(50) DEFAULT SYS_CONTEXT('USERENV', 'SESSIONID'),
    log_level VARCHAR2(10)
);

-- declaration of debug_utils package
CREATE OR REPLACE PACKAGE debug_utils IS
    g_debug_mode BOOLEAN := FALSE;
    
    PROCEDURE enable_debug;
    PROCEDURE disable_debug;
    FUNCTION get_line_num RETURN NUMBER;
    FUNCTION get_module_name RETURN VARCHAR2;
    
    PROCEDURE default_log(p_level VARCHAR2, p_message VARCHAR2, p_line_num  NUMBER := NULL,p_module VARCHAR2 := NULL);
    PROCEDURE log_msg(p_message VARCHAR2, p_line_num NUMBER := NULL);
    PROCEDURE log_variable(p_name VARCHAR2, p_value VARCHAR2, p_line_num NUMBER := NULL);
    PROCEDURE log_error(p_err VARCHAR2, p_line_num NUMBER := NULL);
END debug_utils;

-- declaration of debug_utils package body
CREATE OR REPLACE PACKAGE BODY debug_utils IS
    
    PROCEDURE enable_debug IS
    BEGIN
        g_debug_mode := TRUE;
    END enable_debug;
    
    PROCEDURE disable_debug IS
    BEGIN
        g_debug_mode := FALSE;
    END disable_debug;
    
    -- get line number of the calling line (go to call stack -> line number)
    FUNCTION get_line_num RETURN NUMBER IS
        v_stack   VARCHAR2(4000);
        v_line    VARCHAR2(100);
        v_line_num NUMBER;
    BEGIN
        -- full call stack as text
        v_stack := DBMS_UTILITY.FORMAT_CALL_STACK;
        
        -- Match line like: 0x123abcde       10  procedure HR.TEST_DEBUG
        v_line := REGEXP_SUBSTR(v_stack, '0x[0-9a-f]+[[:space:]]+[0-9]+[[:space:]]+procedure.*', 1, 1, 'i');
        
        IF v_line IS NOT NULL THEN
            -- Extract the number from the second column (line number)
            v_line_num := TO_NUMBER(REGEXP_SUBSTR(v_line, '[[:space:]]+([0-9]+)[[:space:]]+', 1, 1, NULL, 1));
            RETURN v_line_num;
        ELSE
            RETURN NULL;
        END IF;
        
        EXCEPTION
            WHEN OTHERS THEN
                RETURN NULL;
    END get_line_num;
    
    FUNCTION get_module_name RETURN VARCHAR2 IS
        v_stack   VARCHAR2(4000);
        v_line    VARCHAR2(200);
        v_module_name VARCHAR2(100);
    BEGIN
        v_stack := DBMS_UTILITY.FORMAT_CALL_STACK;
        v_line := REGEXP_SUBSTR(v_stack, '0x[0-9a-f]+[[:space:]]+[0-9]+[[:space:]]+procedure[[:space:]]+.+', 1, 1, 'i');
        
        IF v_line IS NOT NULL THEN
            -- Extract the part after 'procedure' (the full name)
            v_module_name := REGEXP_SUBSTR(v_line, 'procedure[[:space:]]+(.+)', 1, 1, NULL, 1);
            RETURN v_module_name;
        ELSE
            RETURN 'UNKNOWN';
        END IF;
        
        EXCEPTION
            WHEN OTHERS THEN
                RETURN 'UNKNOWN';
    END get_module_name;
    
    PROCEDURE default_log(
        p_level     VARCHAR2,
        p_message   VARCHAR2,
        p_line_num  NUMBER := NULL,
        p_module    VARCHAR2 := NULL
    ) IS
        v_line_num  NUMBER := NVL(p_line_num, get_line_num);
        v_module    VARCHAR2(100) := NVL(p_module, get_module_name);
    BEGIN
        IF g_debug_mode THEN
        INSERT INTO debug_log (
            module_name,
            line_no,
            log_message,
            log_level
        ) VALUES (
            v_module,
            v_line_num,
            p_message,
            UPPER(p_level)
        );
        END IF;
    END default_log;
    
    PROCEDURE log_msg(p_message VARCHAR2, p_line_num NUMBER := NULL) IS
    BEGIN
        default_log('INFO', p_message, p_line_num);
    END log_msg;
    
    PROCEDURE log_variable(p_name VARCHAR2, p_value VARCHAR2, p_line_num NUMBER := NULL) IS
    BEGIN
        default_log('WARN', 'Variable : ' || p_name || ' = ' || p_value, p_line_num);
    END log_variable;
    
    PROCEDURE log_error(p_err VARCHAR2, p_line_num NUMBER := NULL) IS
    BEGIN
        default_log('ERROR', 'Error : ' || p_err, p_line_num);
    END log_error;
END debug_utils;

--procedure to test if debug is working
CREATE OR REPLACE PROCEDURE test_debug IS
BEGIN
  debug_utils.enable_debug;

  --procedures test when debug turned on
  debug_utils.log_msg('Process started');
  debug_utils.log_variable('username', 'john_doe');
  debug_utils.log_error('ORA-01403: no data found');
  
  --DBMS_OUTPUT.PUT_LINE(DBMS_UTILITY.FORMAT_CALL_STACK);

  debug_utils.disable_debug;
  -- procedures test when debug turned off
  debug_utils.log_msg('Process started');
  debug_utils.log_variable('username', 'john_doe');
  debug_utils.log_error('ORA-01403: no data found');
END;
/

BEGIN
  test_debug;
END;

/*
    BEGIN
    DELETE FROM debug_log;
    COMMIT;
    END;
*/

-- Part 2 -- creating employee table and logging 
CREATE TABLE employees (
    emp_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    emp_name VARCHAR2(200),
    emp_salary NUMBER DEFAULT 0,
    commission_pct NUMBER DEFAULT NULL
);

-- procedure used to update the employees salaries absed on the commission
CREATE OR REPLACE PROCEDURE adjust_salaries_by_commission IS
    CURSOR emp_cur IS
        SELECT emp_id, emp_salary, commission_pct
        FROM employees
        FOR UPDATE;
        
    v_raise_pct NUMBER;
    v_new_salary NUMBER;
BEGIN
    debug_utils.log_msg('Starting salary adjustment process.');
    
    FOR emp_rec IN emp_cur LOOP
        debug_utils.log_variable('EMPLOYEE_ID', TO_CHAR(emp_rec.emp_id));
        
        IF emp_rec.commission_pct IS NOT NULL THEN
            v_raise_pct := emp_rec.commission_pct;
            debug_utils.log_variable('Using commission_pct', TO_CHAR(v_raise_pct));
        ELSE
            v_raise_pct := 0.02;
            debug_utils.log_msg('Commission PCT is NULL. Defaulting to 2%.');
        END IF;
        
        v_new_salary := emp_rec.emp_salary * (1 + v_raise_pct);
        debug_utils.log_variable('New Salary', TO_CHAR(v_new_salary));
        
        UPDATE employees
        SET emp_salary = v_new_salary
        WHERE CURRENT OF emp_cur;
        
        debug_utils.log_msg('Salary updated.');
    END LOOP;
    
    debug_utils.log_msg('Salary adjustment completed.');
    
    EXCEPTION
        WHEN OTHERS THEN
        debug_utils.log_error('adjust_salaries_by_commission', SQLERRM);
        RAISE;
END;

--test employees
INSERT INTO employees (emp_id, emp_name, emp_salary, commission_pct)
VALUES (101, 'Alice Johnson', 4000, 0.10);  -- 10% raise

INSERT INTO employees (emp_id, emp_name, emp_salary, commission_pct)
VALUES (102, 'Bob Smith', 5000, NULL);      -- 2% raise (default)

INSERT INTO employees (emp_id, emp_name, emp_salary, commission_pct)
VALUES (103, 'Clara White', 3000, 0.05);    -- 5% raise

INSERT INTO employees (emp_id, emp_name, emp_salary, commission_pct)
VALUES (104, 'David Brown', 4500, NULL);    -- 2% raise (default)

COMMIT;

--Part 3 : begin testing the full process
BEGIN
    debug_utils.enable_debug;
END;

BEGIN
    adjust_salaries_by_commission;
END;

SELECT * FROM employees;

SELECT * FROM debug_log;
